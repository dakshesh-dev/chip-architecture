<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Chip Architecture: 2D/3D Hybrid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: rgba(20, 20, 20, 0.9);
            --fpga-color: #00ffcc;
            --cpu-color: #ff3300;
            --text-main: #ffffff;
            --border: #333;
        }

        body { margin: 0; overflow: hidden; background: var(--bg-color); font-family: 'Courier New', monospace; }
        
        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--panel-bg);
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        /* Top Control Bar */
        .top-bar {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }

        .btn-group {
            display: flex;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #444;
        }

        button {
            background: #111;
            color: #888;
            border: none;
            padding: 10px 20px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            font-size: 12px;
        }

        button:hover { background: #222; color: #fff; }
        button.active { background: #333; color: #fff; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
        button.active.fpga { color: var(--fpga-color); border-bottom: 2px solid var(--fpga-color); }
        button.active.cpu { color: var(--cpu-color); border-bottom: 2px solid var(--cpu-color); }

        /* Mode Switcher (2D/3D) */
        .view-switch {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .view-btn {
            width: 120px;
            height: 40px;
            border: 1px solid var(--fpga-color);
            background: rgba(0, 255, 204, 0.1);
            color: var(--fpga-color);
            border-radius: 20px;
            font-size: 14px;
        }
        .view-btn:hover { background: var(--fpga-color); color: #000; }

        /* Stats Corner */
        .stats {
            position: absolute;
            top: 20px; right: 20px;
            text-align: right;
            color: var(--fpga-color);
        }
        .stat-val { font-size: 24px; font-weight: bold; }
        .stat-label { font-size: 10px; opacity: 0.7; }

        /* Canvas Layers */
        #canvas-2d { position: absolute; top: 0; left: 0; z-index: 1; }
        #container-3d { position: absolute; top: 0; left: 0; z-index: 2; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        #container-3d.active { opacity: 1; pointer-events: auto; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar hud-panel">
            <div class="btn-group">
                <button id="btn-fpga" class="active fpga" onclick="setArch('FPGA')">FPGA // PARALLEL</button>
                <button id="btn-cpu" onclick="setArch('CPU')">CPU // SERIAL</button>
            </div>
            <div class="btn-group">
                <button onclick="triggerTraffic()">⚠️ SIMULATE LOAD</button>
            </div>
        </div>

        <div class="stats hud-panel">
            <div id="stat-tps" class="stat-val">0</div>
            <div class="stat-label">ACTIVE BITS (THROUGHPUT)</div>
            <div id="stat-lat" class="stat-val">12.1 µs</div>
            <div class="stat-label">LATENCY</div>
        </div>

        <div class="view-switch">
            <button class="view-btn" onclick="setView('2D')">SCHEMATIC (2D)</button>
            <button class="view-btn" onclick="setView('3D')">INSIDE CHIP (3D)</button>
        </div>
    </div>

    <canvas id="canvas-2d"></canvas>
    <div id="container-3d"></div>

<script>
/**
 * HYBRID ENGINE: CANVAS 2D + THREE.JS 3D
 */

const CONFIG = {
    fpgaColor: '#00ffcc',
    cpuColor: '#ff3300',
    particleCount: 2000, // Visual limit for browser performance (looks like 84k)
    gridSize: 8
};

const state = {
    arch: 'FPGA', // 'FPGA' | 'CPU'
    view: '2D',   // '2D' | '3D'
    tps: 0,
    zoom: 1,
    pan: { x: 0, y: 0 },
    isDrag: false,
    lastMouse: { x: 0, y: 0 }
};

// =========================================================================
// PART 1: 2D SCHEMATIC ENGINE (CANVAS)
// =========================================================================
const canvas = document.getElementById('canvas-2d');
const ctx = canvas.getContext('2d');
let particles = [];
let nodes = [];

function init2D() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    createNodes();
}

class Node {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'dsp', 'mem', 'io'
        this.size = type === 'dsp' ? 20 : 40;
        this.pulse = 0;
    }
    draw() {
        ctx.fillStyle = state.arch === 'FPGA' ? 'rgba(0, 255, 204, 0.1)' : 'rgba(255, 51, 0, 0.1)';
        ctx.strokeStyle = state.arch === 'FPGA' ? CONFIG.fpgaColor : CONFIG.cpuColor;
        ctx.lineWidth = 1;

        if (this.pulse > 0) {
            ctx.fillStyle = state.arch === 'FPGA' ? 'rgba(0, 255, 204, 0.8)' : 'rgba(255, 51, 0, 0.8)';
            this.pulse -= 0.1;
        }

        ctx.beginPath();
        ctx.rect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.fill();
        ctx.stroke();
    }
}

class Bit {
    constructor() {
        this.reset();
    }
    
    reset() {
        this.active = true;
        this.progress = 0;
        this.speed = state.arch === 'FPGA' ? 0.02 + Math.random()*0.03 : 0.005; // CPU is slow
        this.path = [];
        this.targetIndex = 0;
        
        // Define path based on architecture
        if(state.arch === 'FPGA') {
            // FPGA: Memory -> Specific DSP Node -> Memory (Parallel)
            let row = Math.floor(Math.random() * CONFIG.gridSize);
            let col = Math.floor(Math.random() * CONFIG.gridSize);
            let dsp = nodes.find(n => n.gridPos && n.gridPos.r === row && n.gridPos.c === col);
            let mem = nodes[0]; // Left Memory
            let out = nodes[1]; // Right Memory
            this.path = [mem, dsp, out];
        } else {
            // CPU: RAM -> Bus -> Core -> Cache -> RAM (Serial)
            let ram = nodes[0];
            let core = nodes[2 + Math.floor(Math.random()*4)]; // Random core
            this.path = [ram, core, ram];
        }
        
        this.x = this.path[0].x;
        this.y = this.path[0].y;
    }

    update() {
        if(!this.active) return;
        
        let target = this.path[this.targetIndex + 1];
        if(!target) {
            this.reset(); // Loop back
            return;
        }

        let dx = target.x - this.x;
        let dy = target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if(dist < 5) {
            this.targetIndex++;
            target.pulse = 1; // Flash the node
            if(this.targetIndex >= this.path.length - 1) {
                this.reset();
            }
        } else {
            this.x += (dx/dist) * this.speed * (state.arch==='FPGA'?50:20); // Move
        }
    }

    draw() {
        ctx.fillStyle = state.arch === 'FPGA' ? '#ffffff' : '#ffaa00';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
    }
}

function createNodes() {
    nodes = [];
    let cx = canvas.width / 2;
    let cy = canvas.height / 2;

    if (state.arch === 'FPGA') {
        // 8x8 GRID
        let gap = 40;
        let startX = cx - (4 * gap);
        let startY = cy - (4 * gap);
        
        // Memory Banks (Left/Right)
        nodes.push(new Node(startX - 100, cy, 'mem'));
        nodes.push(new Node(cx + (4*gap) + 100, cy, 'mem'));

        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                let n = new Node(startX + c*gap, startY + r*gap, 'dsp');
                n.gridPos = {r, c};
                nodes.push(n);
            }
        }
    } else {
        // CPU LAYOUT
        nodes.push(new Node(cx - 300, cy, 'mem')); // RAM
        nodes.push(new Node(cx - 100, cy, 'mem')); // Cache
        
        // 4 Cores
        for(let i=0; i<4; i++) {
            nodes.push(new Node(cx + 100, cy - 150 + (i*100), 'dsp'));
        }
    }
    
    // Reset Particles
    particles = [];
    for(let i=0; i<CONFIG.particleCount; i++) {
        particles.push(new Bit());
    }
}

// 2D ANIMATION LOOP
function animate2D() {
    if(state.view !== '2D') return;

    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail effect
    ctx.fillRect(0,0, canvas.width, canvas.height);

    // Camera Transform
    ctx.save();
    ctx.translate(state.pan.x, state.pan.y);
    ctx.scale(state.zoom, state.zoom);

    // Draw Lines
    ctx.strokeStyle = '#222';
    ctx.beginPath();
    // (Simplified grid lines for background)
    ctx.stroke();

    nodes.forEach(n => n.draw());
    particles.forEach(p => { p.update(); p.draw(); });

    ctx.restore();
    
    // Update Stats
    state.tps = Math.floor(state.arch === 'FPGA' ? 84000 + Math.random()*500 : 2100 + Math.random()*100);
    document.getElementById('stat-tps').innerText = state.tps.toLocaleString();
    
    requestAnimationFrame(animate2D);
}

// =========================================================================
// PART 2: 3D ENGINE (THREE.JS)
// =========================================================================
let scene, camera, renderer, controls;
let chipMeshes = [];
let dataParticles3D;

function init3D() {
    const container = document.getElementById('container-3d');
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(0, 200, 400);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.1);
    scene.add(ambient);
    const point = new THREE.PointLight(0xffffff, 1);
    point.position.set(100, 200, 100);
    scene.add(point);

    buildChip3D();
}

function buildChip3D() {
    // Clear old
    chipMeshes.forEach(m => scene.remove(m));
    chipMeshes = [];

    const color = state.arch === 'FPGA' ? 0x00ffcc : 0xff3300;
    const material = new THREE.MeshStandardMaterial({ 
        color: 0x111111, 
        emissive: color,
        emissiveIntensity: 0.2,
        roughness: 0.1,
        metalness: 0.8,
        transparent: true,
        opacity: 0.8
    });

    const geometry = new THREE.BoxGeometry(1, 1, 1);

    if (state.arch === 'FPGA') {
        // 8x8 Grid of Towers
        for(let x=0; x<8; x++) {
            for(let z=0; z<8; z++) {
                const mesh = new THREE.Mesh(geometry, material.clone());
                mesh.position.set((x-4)*30, 10, (z-4)*30);
                mesh.scale.set(20, 10 + Math.random()*20, 20); // Random heights
                scene.add(mesh);
                chipMeshes.push(mesh);
            }
        }
    } else {
        // 4 Large Cores
        for(let i=0; i<4; i++) {
            const mesh = new THREE.Mesh(geometry, material.clone());
            mesh.position.set((i-1.5)*60, 20, 0);
            mesh.scale.set(40, 40, 80);
            scene.add(mesh);
            chipMeshes.push(mesh);
        }
    }

    // Floor Grid
    const gridHelper = new THREE.GridHelper(500, 50, 0x333333, 0x222222);
    scene.add(gridHelper);
    chipMeshes.push(gridHelper);

    // 3D Particles
    const partGeom = new THREE.BufferGeometry();
    const positions = new Float32Array(3000 * 3); // 1000 particles
    for(let i=0; i<3000*3; i++) {
        positions[i] = (Math.random() - 0.5) * 300;
    }
    partGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const partMat = new THREE.PointsMaterial({ color: color, size: 2 });
    dataParticles3D = new THREE.Points(partGeom, partMat);
    scene.add(dataParticles3D);
    chipMeshes.push(dataParticles3D);
}

function animate3D() {
    if(state.view !== '3D') return;

    requestAnimationFrame(animate3D);
    controls.update();

    // Pulse effect on chips
    const time = Date.now() * 0.002;
    chipMeshes.forEach((mesh, idx) => {
        if(mesh.material && mesh.material.emissiveIntensity) {
            mesh.material.emissiveIntensity = 0.2 + Math.sin(time + idx)*0.2;
        }
    });

    // Move particles
    const positions = dataParticles3D.geometry.attributes.position.array;
    for(let i=0; i<3000; i++) {
        // Simple flow logic
        positions[i*3 + 2] += state.arch === 'FPGA' ? 2 : 0.5; // Z axis movement
        if(positions[i*3 + 2] > 150) positions[i*3 + 2] = -150;
    }
    dataParticles3D.geometry.attributes.position.needsUpdate = true;
    
    renderer.render(scene, camera);
}

// =========================================================================
// CONTROLLERS
// =========================================================================

function setArch(arch) {
    state.arch = arch;
    
    // UI Update
    document.getElementById('btn-fpga').classList.toggle('active', arch === 'FPGA');
    document.getElementById('btn-cpu').classList.toggle('active', arch === 'CPU');
    
    document.getElementById('stat-lat').innerText = arch === 'FPGA' ? "12.1 µs" : "452.4 µs";
    document.getElementById('stat-lat').style.color = arch === 'FPGA' ? CONFIG.fpgaColor : CONFIG.cpuColor;
    document.querySelector('.stats').style.color = arch === 'FPGA' ? CONFIG.fpgaColor : CONFIG.cpuColor;

    // Rebuild Scenes
    createNodes(); // 2D
    if(scene) buildChip3D(); // 3D
}

function setView(viewMode) {
    state.view = viewMode;
    const c3d = document.getElementById('container-3d');
    
    if(viewMode === '3D') {
        c3d.classList.add('active');
        if(!scene) init3D();
        animate3D();
    } else {
        c3d.classList.remove('active');
        animate2D();
    }
}

function triggerTraffic() {
    // Flash effect
    state.zoom += 0.1;
    setTimeout(() => state.zoom -= 0.1, 100);
}

// MOUSE INTERACTION FOR 2D
canvas.addEventListener('mousedown', e => {
    state.isDrag = true;
    state.lastMouse = { x: e.clientX, y: e.clientY };
});
window.addEventListener('mouseup', () => state.isDrag = false);
window.addEventListener('mousemove', e => {
    if(state.isDrag && state.view === '2D') {
        state.pan.x += e.clientX - state.lastMouse.x;
        state.pan.y += e.clientY - state.lastMouse.y;
        state.lastMouse = { x: e.clientX, y: e.clientY };
    }
});
window.addEventListener('wheel', e => {
    if(state.view === '2D') {
        state.zoom += e.deltaY * -0.001;
        state.zoom = Math.min(Math.max(.5, state.zoom), 3);
    }
});

// START
init2D();
animate2D();
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    createNodes();
});

</script>
</body>
</html>
