<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENTERPRISE CHIP ARCHITECT V11.0 | FINAL BUILD</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* --- VISUAL IDENTITY --- */
        :root {
            --bg-dark: #0d1117;
            --panel-glass: rgba(22, 27, 34, 0.95);
            --border-dark: #30363d;
            --fpga-cyan: #39c5bb;
            --cpu-orange: #f0883e;
            --blueprint-bg: #00305a;
            --text-main: #c9d1d9;
        }

        body {
            margin: 0; overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI Mono', 'Courier New', monospace;
            color: var(--text-main);
            transition: background-color 0.5s ease;
        }

        /* MODE: BLUEPRINT */
        body.mode-blueprint {
            background-color: var(--blueprint-bg);
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        /* --- UI OVERLAY --- */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--panel-glass);
            border: 1px solid var(--border-dark);
            backdrop-filter: blur(10px);
            padding: 12px; margin: 20px;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }

        body.mode-blueprint .hud-panel {
            background: rgba(0, 48, 90, 0.9);
            border: 2px solid #fff;
        }

        /* CONTROLS */
        .top-bar { align-self: center; display: flex; gap: 10px; align-items: center; }
        .divider { width: 1px; height: 20px; background: var(--border-dark); margin: 0 10px; }
        
        button {
            background: #21262d; border: 1px solid var(--border-dark);
            color: #8b949e; padding: 8px 14px;
            font-family: inherit; font-size: 11px; font-weight: 700;
            cursor: pointer; text-transform: uppercase;
            transition: 0.2s; border-radius: 3px;
        }
        button:hover { border-color: #fff; color: #fff; }

        /* ACTIVE BUTTON STATES */
        button.active-fpga { background: rgba(57, 197, 187, 0.2); color: var(--fpga-cyan); border-color: var(--fpga-cyan); }
        button.active-cpu { background: rgba(240, 136, 62, 0.2); color: var(--cpu-orange); border-color: var(--cpu-orange); }
        button.active-view { background: #fff; color: #000; border-color: #fff; }

        /* SIDEBAR */
        .sidebar { position: absolute; top: 100px; right: 0; width: 220px; display: flex; flex-direction: column; gap: 10px; }
        .metric-row { display: flex; justify-content: space-between; border-bottom: 1px dashed var(--border-dark); padding-bottom: 5px; }
        .label { font-size: 10px; color: #8b949e; }
        .value { font-size: 14px; font-weight: bold; color: #fff; }

        /* MINI GRID */
        .grid-status { display: grid; gap: 2px; margin-top: 10px; }
        .mini-node { width: 100%; aspect-ratio: 1; background: #333; transition: background 0.1s; }
        .mini-node.lit-fpga { background: var(--fpga-cyan); box-shadow: 0 0 5px var(--fpga-cyan); }
        .mini-node.lit-cpu { background: var(--cpu-orange); box-shadow: 0 0 5px var(--cpu-orange); }

        /* RENDER LAYERS */
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #canvas-2d { z-index: 1; transition: opacity 0.5s; }
        #container-3d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0; pointer-events: none; transition: opacity 0.5s; }

        /* VIEW STATES */
        body.view-3d #canvas-2d { opacity: 0; pointer-events: none; }
        body.view-3d #container-3d { opacity: 1; pointer-events: auto; z-index: 10; }
        
        /* LOADING */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            color: var(--fpga-cyan); letter-spacing: 2px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">INITIALIZING SILICON FABRIC...</div>

    <div id="hud-layer">
        <div class="top-bar hud-panel">
            <span style="font-weight:bold; letter-spacing:1px; margin-right:15px; border-right:1px solid #555; padding-right:15px;">ARCHITECT.IO</span>
            
            <button id="btn-fpga" class="active-fpga" onclick="setArch('FPGA')">FPGA // PARALLEL</button>
            <button id="btn-cpu" onclick="setArch('CPU')">CPU // SERIAL</button>
            <div class="divider"></div>
            <button id="btn-live" class="active-view" onclick="setView('LIVE')">LIVE SCHEMATIC</button>
            <button id="btn-3d" onclick="setView('3D')">3D SILICON</button>
            <button id="btn-paper" onclick="setView('BLUEPRINT')">BLUEPRINT</button>
            <div class="divider"></div>
            <button onclick="triggerStress()">⚠️ STRESS TEST</button>
        </div>

        <div class="sidebar hud-panel">
            <div class="metric-row">
                <span class="label">THROUGHPUT</span>
                <span class="value" id="val-tps">0 TPS</span>
            </div>
            <div class="metric-row">
                <span class="label">ACTIVE CORES</span>
                <span class="value" id="val-active">0</span>
            </div>
            <div class="metric-row">
                <span class="label">CONFIG</span>
                <span class="value" id="val-config">PARALLEL GRID</span>
            </div>
            <div style="margin-top:10px;">
                <span class="label">CORE MAP</span>
                <div id="mini-grid" class="grid-status"></div>
            </div>
        </div>
    </div>

    <canvas id="canvas-2d"></canvas>
    <div id="container-3d"></div>

<script>
/**
 * ------------------------------------------------------------------
 * ENTERPRISE CHIP ARCHITECT V11 (FINAL)
 * ------------------------------------------------------------------
 */

const CONFIG = {
    FPGA: {
        color: '#39c5bb',
        gridCols: 8, // 8x8 = 64
        tpsBase: 84000,
        label: 'XC7A100T // 8x8 DSP'
    },
    CPU: {
        color: '#f0883e',
        gridCols: 4, // 4x4 = 16
        tpsBase: 4200,
        label: 'i9-14900K // 16-CORE'
    }
};

const state = {
    arch: 'FPGA',
    view: 'LIVE',
    nodes: [],
    packets: [],
    stress: false,
    frame: 0
};

// =========================================================================
// 1. INITIALIZATION & LOGIC BUILDER
// =========================================================================

window.onload = () => {
    initCanvas();
    init3D();
    buildLogic(); // Build initial nodes
    animate();
    
    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);
    }, 1000);
};

function buildLogic() {
    state.nodes = [];
    state.packets = [];
    
    const isFPGA = state.arch === 'FPGA';
    const cols = isFPGA ? 8 : 4;
    const rows = isFPGA ? 8 : 4;
    const gap = isFPGA ? 80 : 120;
    
    // Calculate centering offset based on virtual 1000x1000 canvas
    const gridW = (cols-1) * gap;
    const startX = (1000 - gridW) / 2;
    const startY = (1000 - gridW) / 2;

    // Create Nodes
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            state.nodes.push({
                id: r*cols + c,
                x: startX + c*gap,
                y: startY + r*gap,
                load: 0,
                type: 'CORE'
            });
        }
    }
    
    // For CPU, add Cache blocks in the middle visually (logic only)
    if (!isFPGA) {
        state.nodes.push({ id: 'L3', x: 500, y: 500, type: 'CACHE', load: 0 });
    }

    // Update UI
    document.getElementById('val-config').innerText = isFPGA ? 'PARALLEL GRID' : 'SERIAL RING';
    const gridEl = document.getElementById('mini-grid');
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    for(let i=0; i<rows*cols; i++) {
        let d = document.createElement('div');
        d.className = 'mini-node';
        gridEl.appendChild(d);
    }

    // Rebuild 3D Scene
    build3DScene();
}

// =========================================================================
// 2. 2D SCHEMATIC ENGINE (CANVAS)
// =========================================================================

const canvas = document.getElementById('canvas-2d');
const ctx = canvas.getContext('2d');

function initCanvas() {
    window.addEventListener('resize', resize);
    resize();
}
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function draw2D() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const isBlue = state.view === 'BLUEPRINT';
    const theme = CONFIG[state.arch];
    
    // Scale to fit 1000x1000 virtual space into screen
    ctx.save();
    const scale = Math.min(canvas.width/1200, canvas.height/1200);
    const offsetX = (canvas.width - 1000*scale)/2;
    const offsetY = (canvas.height - 1000*scale)/2;
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // DRAW WIRES / SUBSTRATE
    ctx.strokeStyle = isBlue ? 'rgba(255,255,255,0.3)' : '#30363d';
    ctx.lineWidth = 2;
    
    if (state.arch === 'FPGA') {
        // Grid Mesh
        for(let i=0; i<=8; i++) {
            let p = 220 + (i*80);
            ctx.beginPath(); ctx.moveTo(p, 220); ctx.lineTo(p, 780); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(220, p); ctx.lineTo(780, p); ctx.stroke();
        }
    } else {
        // Ring Bus
        ctx.beginPath();
        ctx.rect(300, 300, 400, 400); // Inner Ring
        ctx.rect(200, 200, 600, 600); // Outer Ring
        ctx.stroke();
        // Cache Block
        ctx.fillStyle = isBlue ? 'transparent' : '#161b22';
        ctx.fillRect(400, 400, 200, 200);
        ctx.strokeRect(400, 400, 200, 200);
    }

    // DRAW NODES
    state.nodes.forEach(n => {
        if (n.type === 'CACHE') return; // Don't draw L3 as a node
        
        const size = state.arch === 'FPGA' ? 40 : 80;
        
        // Load Calculation
        let active = n.load > 0.05;
        let color = active ? theme.color : '#21262d';
        
        if (isBlue) {
            // Blueprint Style
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
            ctx.beginPath(); 
            ctx.moveTo(n.x-size/2, n.y-size/2); 
            ctx.lineTo(n.x+size/2, n.y+size/2); 
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(n.id, n.x - 5, n.y - size/2 - 5);
        } else {
            // Live Style
            ctx.fillStyle = color;
            ctx.globalAlpha = active ? 1 : 0.4;
            
            // Glow
            if (active) {
                ctx.shadowColor = theme.color;
                ctx.shadowBlur = 20;
            } else {
                ctx.shadowBlur = 0;
            }
            
            ctx.fillRect(n.x - size/2, n.y - size/2, size, size);
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
            
            // Core Text
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.font = state.arch === 'FPGA' ? '8px monospace' : '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(state.arch === 'FPGA' ? '' : 'CORE', n.x, n.y+4);
        }
        
        // Decay
        n.load *= 0.9;
    });

    // DRAW PACKETS
    if (!isBlue) {
        state.packets.forEach(p => {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
            ctx.fill();
            // Simple trail
            ctx.strokeStyle = theme.color;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - p.vx*5, p.y - p.vy*5);
            ctx.stroke();
        });
    }

    ctx.restore();
}

// =========================================================================
// 3. 3D SILICON ENGINE (THREE.JS)
// =========================================================================

let scene, camera, renderer, controls, chipGroup;

function init3D() {
    const container = document.getElementById('container-3d');
    
    scene = new THREE.Scene(); // Transparent background
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.set(0, 500, 600);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.8;
    
    const amb = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 1);
    dir.position.set(100, 200, 100);
    scene.add(dir);
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function build3DScene() {
    if (chipGroup) scene.remove(chipGroup);
    chipGroup = new THREE.Group();
    
    const theme = CONFIG[state.arch];
    const matBase = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 });
    const matNode = new THREE.MeshStandardMaterial({ 
        color: 0x222222, 
        emissive: theme.color, 
        emissiveIntensity: 0.1,
        roughness: 0.4,
        metalness: 0.8
    });
    
    // Substrate
    const base = new THREE.Mesh(new THREE.BoxGeometry(700, 10, 700), matBase);
    base.position.y = -10;
    chipGroup.add(base);
    
    // Nodes
    state.nodes.forEach((n, i) => {
        if (n.type === 'CACHE') return;
        
        let size = state.arch === 'FPGA' ? 40 : 100;
        let h = 20 + Math.random() * 20;
        
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(size, h, size), matNode.clone());
        
        // Map 1000x1000 2D coords to 3D center-zeroed space
        let x = n.x - 500;
        let z = n.y - 500;
        
        mesh.position.set(x, h/2, z);
        mesh.userData = { id: i }; // Bind to logic node index
        chipGroup.add(mesh);
    });
    
    scene.add(chipGroup);
}

function update3D() {
    // Sync 3D meshes with 2D logic state
    chipGroup.children.forEach(mesh => {
        if (mesh.userData.id === undefined) return;
        
        const node = state.nodes[mesh.userData.id];
        if (node && node.load > 0.05) {
            mesh.material.emissiveIntensity = 0.2 + (node.load * 2);
            mesh.scale.y = 1 + (node.load * 0.5);
        } else {
            mesh.material.emissiveIntensity = 0.1;
            mesh.scale.y = 1;
        }
    });
    
    controls.update();
    renderer.render(scene, camera);
}

// =========================================================================
// 4. ANIMATION LOOP & CONTROLLERS
// =========================================================================

class Packet {
    constructor() {
        this.active = true;
        this.vx = 0;
        this.vy = 0;
        
        // Pick random target core
        const cores = state.nodes.filter(n => n.type === 'CORE');
        const target = cores[Math.floor(Math.random() * cores.length)];
        
        if (state.arch === 'FPGA') {
            // Left to Right Flow
            this.x = 0; 
            this.y = target.y;
            this.tx = 1000;
            this.ty = target.y;
            this.speed = 15;
        } else {
            // Top (RAM) to Center (Cache) to Core
            this.x = 500;
            this.y = 0;
            this.tx = target.x;
            this.ty = target.y;
            this.speed = 8; // CPU slower visually
        }
    }
    
    update() {
        const dx = this.tx - this.x;
        const dy = this.ty - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < 10) {
            this.active = false;
            // Hit logic
            state.nodes.forEach(n => {
                // If packet is near a node, light it up
                // Simplified hit detection for visual effect
                if (Math.abs(n.x - this.x) < 60 && Math.abs(n.y - this.y) < 60) {
                    n.load = 1.0;
                }
            });
        } else {
            this.vx = (dx/dist) * this.speed;
            this.vy = (dy/dist) * this.speed;
            this.x += this.vx;
            this.y += this.vy;
            
            // Mid-flight collision check (lighting up nodes as it passes)
            state.nodes.forEach(n => {
                if (Math.abs(n.x - this.x) < 40 && Math.abs(n.y - this.y) < 40) {
                    n.load = 1.0;
                }
            });
        }
    }
}

function animate() {
    state.frame++;
    
    // Spawn Packets
    const rate = state.stress ? 5 : 20;
    if (state.frame % rate === 0) {
        state.packets.push(new Packet());
    }
    
    // Update Packets
    state.packets.forEach(p => p.update());
    state.packets = state.packets.filter(p => p.active);
    
    // Update UI Stats
    if (state.frame % 10 === 0) {
        // TPS
        const base = CONFIG[state.arch].tpsBase;
        const active = state.nodes.filter(n => n.load > 0.05).length;
        document.getElementById('val-tps').innerText = Math.floor(base + (active * 150)).toLocaleString() + " TPS";
        document.getElementById('val-active').innerText = active;
        
        // Mini Grid
        const minis = document.getElementsByClassName('mini-node');
        const themeClass = state.arch === 'FPGA' ? 'lit-fpga' : 'lit-cpu';
        state.nodes.forEach((n, i) => {
            if (minis[i]) {
                if (n.load > 0.05) minis[i].classList.add(themeClass);
                else minis[i].classList.remove(themeClass);
            }
        });
    }

    // Render
    if (state.view === '3D') update3D();
    else draw2D();
    
    requestAnimationFrame(animate);
}

// --- CONTROLS ---

function setArch(arch) {
    if (state.arch === arch) return;
    state.arch = arch;
    
    document.getElementById('btn-fpga').className = arch === 'FPGA' ? 'active-fpga' : '';
    document.getElementById('btn-cpu').className = arch === 'CPU' ? 'active-cpu' : '';
    
    buildLogic();
}

function setView(view) {
    state.view = view;
    document.body.className = `mode-${view === 'BLUEPRINT' ? 'blueprint' : 'dark'} view-${view === '3D' ? '3d' : '2d'}`;
    
    ['live', '3d', 'paper'].forEach(id => document.getElementById('btn-'+id).className = '');
    
    let activeId = 'btn-live';
    if(view === '3D') activeId = 'btn-3d';
    if(view === 'BLUEPRINT') activeId = 'btn-paper';
    document.getElementById(activeId).className = 'active-view';
}

function triggerStress() {
    state.stress = true;
    setTimeout(() => state.stress = false, 2000);
}

</script>
</body>
</html>
