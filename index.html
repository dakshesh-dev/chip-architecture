<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENTERPRISE CHIP ARCHITECT V12.0 | REALISM BUILD</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* --- VISUAL IDENTITY --- */
        :root {
            --bg-dark: #0d1117;
            --panel-glass: rgba(22, 27, 34, 0.95);
            --border-dark: #30363d;
            --fpga-cyan: #39c5bb;
            --cpu-orange: #f0883e;
            --blueprint-bg: #00305a;
            --text-main: #c9d1d9;
        }

        body {
            margin: 0; overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI Mono', 'Courier New', monospace;
            color: var(--text-main);
            transition: background-color 0.5s ease;
        }

        /* MODE: BLUEPRINT */
        body.mode-blueprint {
            background-color: var(--blueprint-bg);
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        /* --- UI OVERLAY --- */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--panel-glass);
            border: 1px solid var(--border-dark);
            backdrop-filter: blur(10px);
            padding: 12px; margin: 20px;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }

        body.mode-blueprint .hud-panel {
            background: rgba(0, 48, 90, 0.9);
            border: 2px solid #fff;
        }

        /* CONTROLS */
        .top-bar { align-self: center; display: flex; gap: 10px; align-items: center; }
        .divider { width: 1px; height: 20px; background: var(--border-dark); margin: 0 10px; }
        
        button {
            background: #21262d; border: 1px solid var(--border-dark);
            color: #8b949e; padding: 8px 14px;
            font-family: inherit; font-size: 11px; font-weight: 700;
            cursor: pointer; text-transform: uppercase;
            transition: 0.2s; border-radius: 3px;
        }
        button:hover { border-color: #fff; color: #fff; }

        /* ACTIVE BUTTON STATES */
        button.active-fpga { background: rgba(57, 197, 187, 0.2); color: var(--fpga-cyan); border-color: var(--fpga-cyan); }
        button.active-cpu { background: rgba(240, 136, 62, 0.2); color: var(--cpu-orange); border-color: var(--cpu-orange); }
        button.active-view { background: #fff; color: #000; border-color: #fff; }

        /* SIDEBAR */
        .sidebar { position: absolute; top: 100px; right: 0; width: 220px; display: flex; flex-direction: column; gap: 10px; }
        .metric-row { display: flex; justify-content: space-between; border-bottom: 1px dashed var(--border-dark); padding-bottom: 5px; }
        .label { font-size: 10px; color: #8b949e; }
        .value { font-size: 14px; font-weight: bold; color: #fff; }

        /* MINI GRID */
        .grid-status { display: grid; gap: 2px; margin-top: 10px; }
        .mini-node { width: 100%; aspect-ratio: 1; background: #333; transition: background 0.1s; }
        .mini-node.lit-fpga { background: var(--fpga-cyan); box-shadow: 0 0 5px var(--fpga-cyan); }
        .mini-node.lit-cpu { background: var(--cpu-orange); box-shadow: 0 0 5px var(--cpu-orange); }

        /* RENDER LAYERS */
        canvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #canvas-2d { z-index: 1; transition: opacity 0.5s; }
        #container-3d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0; pointer-events: none; transition: opacity 0.5s; }

        /* VIEW STATES */
        body.view-3d #canvas-2d { opacity: 0; pointer-events: none; }
        body.view-3d #container-3d { opacity: 1; pointer-events: auto; z-index: 10; }
        
        /* LOADING */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            color: var(--fpga-cyan); letter-spacing: 2px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">FABRICATING SILICON DIE...</div>

    <div id="hud-layer">
        <div class="top-bar hud-panel">
            <span style="font-weight:bold; letter-spacing:1px; margin-right:15px; border-right:1px solid #555; padding-right:15px;">ARCHITECT.IO</span>
            
            <button id="btn-fpga" class="active-fpga" onclick="setArch('FPGA')">FPGA // PARALLEL</button>
            <button id="btn-cpu" onclick="setArch('CPU')">CPU // SERIAL</button>
            <div class="divider"></div>
            <button id="btn-live" class="active-view" onclick="setView('LIVE')">LIVE SCHEMATIC</button>
            <button id="btn-3d" onclick="setView('3D')">3D SILICON</button>
            <button id="btn-paper" onclick="setView('BLUEPRINT')">BLUEPRINT</button>
            <div class="divider"></div>
            <button onclick="triggerStress()">⚠️ STRESS TEST</button>
        </div>

        <div class="sidebar hud-panel">
            <div class="metric-row">
                <span class="label">THROUGHPUT</span>
                <span class="value" id="val-tps">0 TPS</span>
            </div>
            <div class="metric-row">
                <span class="label">ACTIVE CORES</span>
                <span class="value" id="val-active">0</span>
            </div>
            <div class="metric-row">
                <span class="label">CONFIG</span>
                <span class="value" id="val-config">PARALLEL GRID</span>
            </div>
            <div style="margin-top:10px;">
                <span class="label">CORE MAP</span>
                <div id="mini-grid" class="grid-status"></div>
            </div>
        </div>
    </div>

    <canvas id="canvas-2d"></canvas>
    <div id="container-3d"></div>

<script>
/**
 * ------------------------------------------------------------------
 * ENTERPRISE CHIP ARCHITECT V12 (REALISM BUILD)
 * ------------------------------------------------------------------
 */

const CONFIG = {
    FPGA: {
        color: '#39c5bb',
        gridCols: 8, // 8x8 = 64
        tpsBase: 84000,
        label: 'XC7A100T // 8x8 DSP'
    },
    CPU: {
        color: '#f0883e',
        gridCols: 4, // 4x4 = 16
        tpsBase: 4200,
        label: 'i9-14900K // 16-CORE'
    }
};

const state = {
    arch: 'FPGA',
    view: 'LIVE',
    nodes: [],
    packets: [],
    stress: false,
    frame: 0
};

// =========================================================================
// 1. INITIALIZATION & LOGIC BUILDER
// =========================================================================

window.onload = () => {
    initCanvas();
    init3D();
    buildLogic(); // Build initial nodes
    animate();
    
    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);
    }, 1000);
};

function buildLogic() {
    state.nodes = [];
    state.packets = [];
    
    const isFPGA = state.arch === 'FPGA';
    const cols = isFPGA ? 8 : 4;
    const rows = isFPGA ? 8 : 4;
    const gap = isFPGA ? 80 : 120;
    
    // Calculate centering offset based on virtual 1000x1000 canvas
    const gridW = (cols-1) * gap;
    const startX = (1000 - gridW) / 2;
    const startY = (1000 - gridW) / 2;

    // Create Nodes
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            state.nodes.push({
                id: r*cols + c,
                x: startX + c*gap,
                y: startY + r*gap,
                load: 0,
                type: 'CORE'
            });
        }
    }
    
    // For CPU, add Cache blocks in the middle visually (logic only)
    if (!isFPGA) {
        state.nodes.push({ id: 'L3', x: 500, y: 500, type: 'CACHE', load: 0 });
    }

    // Update UI
    document.getElementById('val-config').innerText = isFPGA ? 'PARALLEL GRID' : 'SERIAL RING';
    const gridEl = document.getElementById('mini-grid');
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    for(let i=0; i<rows*cols; i++) {
        let d = document.createElement('div');
        d.className = 'mini-node';
        gridEl.appendChild(d);
    }

    // Rebuild 3D Scene
    build3DScene();
}

// =========================================================================
// 2. 2D SCHEMATIC ENGINE (CANVAS)
// =========================================================================

const canvas = document.getElementById('canvas-2d');
const ctx = canvas.getContext('2d');

function initCanvas() {
    window.addEventListener('resize', resize);
    resize();
}
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

class Packet {
    constructor() {
        this.active = true;
        this.segment = 0;
        
        // Pick random target core
        const cores = state.nodes.filter(n => n.type === 'CORE');
        const target = cores[Math.floor(Math.random() * cores.length)];
        
        this.path = [];

        if (state.arch === 'FPGA') {
            // MANHATTAN ROUTING PATTERN (Circuit Traces)
            // 1. Start Left (PCIe)
            // 2. Travel Horizontal to correct column
            // 3. Travel Vertical to core
            // 4. Output Right
            
            const startY = 500; // Bus entrance
            
            this.path = [
                {x: 0, y: startY},             // In
                {x: target.x, y: startY},      // Horizontal Bus Move
                {x: target.x, y: target.y},    // Vertical Branch
                {x: 1000, y: target.y}         // Output
            ];
            
            this.pos = { ...this.path[0] };
            this.speed = 15;
            
        } else {
            // CPU SERIAL PATTERN
            // 1. RAM (Top)
            // 2. L3 (Center)
            // 3. Core
            // 4. L3 (Center)
            this.path = [
                {x: 500, y: 0},
                {x: 500, y: 500},
                {x: target.x, y: target.y},
                {x: 500, y: 500}
            ];
            this.pos = { ...this.path[0] };
            this.speed = 8;
        }
    }
    
    update() {
        if(!this.active) return;
        
        const target = this.path[this.segment + 1];
        if(!target) {
            this.active = false;
            return;
        }
        
        const dx = target.x - this.pos.x;
        const dy = target.y - this.pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist < this.speed) {
            // Reached waypoint
            this.pos.x = target.x;
            this.pos.y = target.y;
            this.segment++;
            
            // Hit Check
            state.nodes.forEach(n => {
                 if (Math.abs(n.x - this.pos.x) < 20 && Math.abs(n.y - this.pos.y) < 20) {
                     n.load = 1.0;
                 }
            });
        } else {
            // Move
            this.pos.x += (dx/dist) * this.speed;
            this.pos.y += (dy/dist) * this.speed;
        }
    }
}

function draw2D() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const isBlue = state.view === 'BLUEPRINT';
    const theme = CONFIG[state.arch];
    
    // Scale Viewport
    ctx.save();
    const scale = Math.min(canvas.width/1200, canvas.height/1200);
    const offsetX = (canvas.width - 1000*scale)/2;
    const offsetY = (canvas.height - 1000*scale)/2;
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // DRAW WIRES / SUBSTRATE
    ctx.strokeStyle = isBlue ? 'rgba(255,255,255,0.3)' : '#30363d';
    ctx.lineWidth = 2;
    
    if (state.arch === 'FPGA') {
        // Bus Lines (Horizontal)
        ctx.beginPath();
        ctx.moveTo(0, 500); ctx.lineTo(1000, 500); // Main Bus
        // Vertical drops
        for(let i=0; i<8; i++) {
            let x = 220 + (i*80);
            ctx.moveTo(x, 220); ctx.lineTo(x, 780);
        }
        ctx.stroke();
    } else {
        // Ring Bus
        ctx.beginPath();
        ctx.rect(300, 300, 400, 400); // Inner Ring
        ctx.rect(200, 200, 600, 600); // Outer Ring
        ctx.stroke();
        // Cache Block
        ctx.fillStyle = isBlue ? 'transparent' : '#161b22';
        ctx.fillRect(400, 400, 200, 200);
        ctx.strokeRect(400, 400, 200, 200);
    }

    // DRAW NODES
    state.nodes.forEach(n => {
        if (n.type === 'CACHE') return;
        
        const size = state.arch === 'FPGA' ? 40 : 80;
        let active = n.load > 0.05;
        let color = active ? theme.color : '#21262d';
        
        if (isBlue) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
            ctx.beginPath(); 
            ctx.moveTo(n.x-size/2, n.y-size/2); 
            ctx.lineTo(n.x+size/2, n.y+size/2); 
            ctx.stroke();
        } else {
            ctx.fillStyle = color;
            ctx.globalAlpha = active ? 1 : 0.4;
            
            // Glow
            if (active) {
                ctx.shadowColor = theme.color;
                ctx.shadowBlur = 20;
            } else {
                ctx.shadowBlur = 0;
            }
            
            ctx.fillRect(n.x - size/2, n.y - size/2, size, size);
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        n.load *= 0.9;
    });

    // DRAW PACKETS
    if (!isBlue) {
        state.packets.forEach(p => {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.pos.x, p.pos.y, 3, 0, Math.PI*2);
            ctx.fill();
        });
    } else {
        ctx.fillStyle = '#fff';
        ctx.font = '20px monospace';
        ctx.fillText("FIG 1.1: ARCHITECTURAL BLUEPRINT", 50, 950);
    }
    
    ctx.restore();
}

// =========================================================================
// 3. 3D SILICON ENGINE (REALISM MODE - NO FLASHING)
// =========================================================================

let scene, camera, renderer, controls, chipGroup;

function init3D() {
    const container = document.getElementById('container-3d');
    
    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.set(0, 600, 600);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0;
    
    // STUDIO LIGHTING
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    
    const spot = new THREE.SpotLight(0xffffff, 1.5);
    spot.position.set(500, 800, 500);
    spot.lookAt(0,0,0);
    scene.add(spot);
    
    const blueRim = new THREE.PointLight(0x4455ff, 1);
    blueRim.position.set(-500, 200, -500);
    scene.add(blueRim);
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function build3DScene() {
    if (chipGroup) scene.remove(chipGroup);
    chipGroup = new THREE.Group();
    
    // MATERIAL LIBRARY (REALISTIC)
    const matPCB = new THREE.MeshStandardMaterial({ 
        color: 0x004400, roughness: 0.8, metalness: 0.1 
    });
    const matSilicon = new THREE.MeshStandardMaterial({ 
        color: 0x111111, roughness: 0.2, metalness: 0.6 
    });
    const matGold = new THREE.MeshStandardMaterial({ 
        color: 0xffaa00, roughness: 0.1, metalness: 1.0 
    });
    const matSilverIHS = new THREE.MeshStandardMaterial({ 
        color: 0xdddddd, roughness: 0.3, metalness: 0.9 
    });
    
    // 1. PCB SUBSTRATE (Green Board)
    const pcb = new THREE.Mesh(new THREE.BoxGeometry(700, 10, 700), matPCB);
    pcb.position.y = -10;
    chipGroup.add(pcb);
    
    // 2. GOLD PINS (Decorative)
    for(let i=0; i<4; i++) {
        const pin = new THREE.Mesh(new THREE.BoxGeometry(600, 2, 10), matGold);
        if(i<2) pin.position.set(0, -4, i===0 ? 320 : -320);
        else {
            pin.rotation.y = Math.PI/2;
            pin.position.set(i===2 ? 320 : -320, -4, 0);
        }
        chipGroup.add(pin);
    }

    if (state.arch === 'FPGA') {
        // FPGA LOOK: Naked Die (Black square in middle) + Caps
        const die = new THREE.Mesh(new THREE.BoxGeometry(400, 20, 400), matSilicon);
        die.position.y = 5;
        chipGroup.add(die);
        
        // Add tiny capacitors around the die
        const capGeo = new THREE.BoxGeometry(20, 10, 40);
        const matCap = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
        for(let i=0; i<10; i++) {
            const cap = new THREE.Mesh(capGeo, matCap);
            cap.position.set(-250, 0, -200 + (i*50));
            chipGroup.add(cap);
        }

    } else {
        // CPU LOOK: Silver Heat Spreader (IHS)
        // Complex shape: base plate + raised center
        const ihsBase = new THREE.Mesh(new THREE.BoxGeometry(500, 15, 500), matSilverIHS);
        ihsBase.position.y = 5;
        chipGroup.add(ihsBase);
        
        const ihsTop = new THREE.Mesh(new THREE.BoxGeometry(350, 5, 350), matSilverIHS);
        ihsTop.position.y = 15;
        chipGroup.add(ihsTop);
    }
    
    scene.add(chipGroup);
}

// =========================================================================
// 4. ANIMATION LOOP & CONTROLLERS
// =========================================================================

function animate() {
    state.frame++;
    
    // SPAWN PACKETS
    const rate = state.stress ? 2 : 10;
    if (state.frame % rate === 0) {
        state.packets.push(new Packet());
    }
    
    // UPDATE LOGIC
    state.packets.forEach(p => p.update());
    state.packets = state.packets.filter(p => p.active);
    
    // UPDATE UI (TPS Stats)
    if (state.frame % 10 === 0) {
        const base = CONFIG[state.arch].tpsBase;
        const active = state.nodes.filter(n => n.load > 0.05).length;
        document.getElementById('val-tps').innerText = Math.floor(base + (state.packets.length * 100)).toLocaleString() + " TPS";
        document.getElementById('val-active').innerText = active;
        
        // Update Mini Grid (Lights up in HUD, but not in 3D)
        const minis = document.getElementsByClassName('mini-node');
        const themeClass = state.arch === 'FPGA' ? 'lit-fpga' : 'lit-cpu';
        state.nodes.forEach((n, i) => {
            if (minis[i]) {
                if (n.type === 'CORE' && n.load > 0.05) minis[i].classList.add(themeClass);
                else minis[i].classList.remove(themeClass);
            }
        });
    }

    // RENDER
    if (state.view === '3D') {
        controls.update();
        renderer.render(scene, camera);
    } else {
        draw2D();
    }
    
    requestAnimationFrame(animate);
}

// CONTROLS
function setArch(arch) {
    if (state.arch === arch) return;
    state.arch = arch;
    
    document.getElementById('btn-fpga').className = arch === 'FPGA' ? 'active-fpga' : '';
    document.getElementById('btn-cpu').className = arch === 'CPU' ? 'active-cpu' : '';
    
    buildLogic();
}

function setView(view) {
    state.view = view;
    document.body.className = `mode-${view === 'BLUEPRINT' ? 'blueprint' : 'dark'} view-${view === '3D' ? '3d' : '2d'}`;
    
    ['live', '3d', 'paper'].forEach(id => document.getElementById('btn-'+id).className = '');
    
    let activeId = 'btn-live';
    if(view === '3D') activeId = 'btn-3d';
    if(view === 'BLUEPRINT') activeId = 'btn-paper';
    document.getElementById(activeId).className = 'active-view';
}

function triggerStress() {
    state.stress = true;
    setTimeout(() => state.stress = false, 2000);
}

</script>
</body>
</html>
