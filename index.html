<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ENTERPRISE CHIP ARCHITECT V10.0 | MULTI-ARCH ENGINE</title>
    
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* --- VISUAL IDENTITY SYSTEM --- */
        :root {
            /* DARK MODE (Live View) */
            --bg-dark: #0d1117;
            --panel-glass: rgba(22, 27, 34, 0.95);
            --border-dark: #30363d;
            
            /* BLUEPRINT MODE */
            --bg-blue: #00305a; /* Classic Blueprint Blue */
            --line-blue: #a3c9e9;
            
            /* ACCENTS */
            --fpga-cyan: #39c5bb;
            --cpu-orange: #f0883e;
            --text-main: #c9d1d9;
            --text-dim: #8b949e;
        }

        body {
            margin: 0; overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI Mono', 'Courier New', monospace;
            color: var(--text-main);
            transition: background-color 0.5s ease;
        }

        /* --- MODE-SPECIFIC STYLES --- */
        body.mode-blueprint {
            background-color: var(--bg-blue);
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        /* Hides HUD panels in blueprint mode for clean paper look, optional */
        body.mode-blueprint .hud-panel {
            background: rgba(0, 48, 90, 0.9);
            border: 2px solid #fff;
            box-shadow: none;
        }

        /* --- HEADS UP DISPLAY --- */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            pointer-events: auto;
            background: var(--panel-glass);
            border: 1px solid var(--border-dark);
            backdrop-filter: blur(10px);
            padding: 12px; margin: 20px;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        /* TOP CONTROL BAR */
        .top-bar {
            align-self: center; display: flex; gap: 10px; align-items: center;
            flex-wrap: wrap; justify-content: center;
        }

        .divider { width: 1px; height: 20px; background: var(--border-dark); margin: 0 10px; }

        h1 {
            margin: 0 15px 0 0; font-size: 14px; letter-spacing: 1px;
            color: #fff; border-right: 1px solid var(--border-dark);
            padding-right: 15px;
        }

        /* BUTTONS */
        button {
            background: #21262d; border: 1px solid var(--border-dark);
            color: var(--text-dim); padding: 8px 14px;
            font-family: inherit; font-size: 11px; font-weight: 700;
            cursor: pointer; text-transform: uppercase;
            transition: 0.2s; border-radius: 3px;
        }

        button:hover { border-color: #fff; color: #fff; }

        /* ACTIVE STATES */
        button.active-fpga { background: rgba(57, 197, 187, 0.2); color: var(--fpga-cyan); border-color: var(--fpga-cyan); }
        button.active-cpu { background: rgba(240, 136, 62, 0.2); color: var(--cpu-orange); border-color: var(--cpu-orange); }
        button.active-view { background: #fff; color: #000; border-color: #fff; }

        /* SIDEBAR TELEMETRY */
        .sidebar {
            position: absolute; top: 100px; right: 0; width: 200px;
            display: flex; flex-direction: column; gap: 10px;
        }

        .metric-row {
            display: flex; justify-content: space-between;
            border-bottom: 1px dashed var(--border-dark);
            padding-bottom: 5px;
        }

        .label { font-size: 10px; color: var(--text-dim); }
        .value { font-size: 14px; font-weight: bold; color: #fff; }

        /* NODE GRID MINI-MAP */
        .grid-status {
            display: grid; gap: 2px; margin-top: 10px;
            /* Default 8x8, changed by JS for CPU */
            grid-template-columns: repeat(8, 1fr); 
        }
        .mini-node {
            width: 100%; aspect-ratio: 1; background: #333;
            transition: background 0.1s;
        }
        .mini-node.active-fpga { background: var(--fpga-cyan); }
        .mini-node.active-cpu { background: var(--cpu-orange); }

        /* CANVAS LAYERS */
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #container-3d { opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 10; }
        
        /* VIEW MODES */
        body.view-3d #container-3d { opacity: 1; pointer-events: auto; }
        body.view-3d canvas { opacity: 0; }

        /* LOADING */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            font-size: 12px; color: var(--fpga-cyan); letter-spacing: 2px;
            transition: opacity 0.5s;
        }

    </style>
</head>
<body>

    <div id="loader">INITIALIZING HARDWARE ABSTRACTION LAYER...</div>

    <div id="hud-layer">
        <div class="top-bar hud-panel">
            <h1 id="brand-header">ARCHITECT.IO</h1>
            
            <button id="btn-arch-fpga" class="active-fpga" onclick="switchArch('FPGA')">FPGA // DSP MATRIX</button>
            <button id="btn-arch-cpu" onclick="switchArch('CPU')">CPU // i9 EXTREME</button>
            
            <div class="divider"></div>
            
            <button id="btn-view-live" class="active-view" onclick="switchView('LIVE')">LIVE SCHEMATIC</button>
            <button id="btn-view-3d" onclick="switchView('3D')">3D SILICON</button>
            <button id="btn-view-blue" onclick="switchView('BLUEPRINT')">PAPER BLUEPRINT</button>
            
            <div class="divider"></div>
            <button onclick="triggerLoad()">⚠️ STRESS TEST</button>
        </div>

        <div class="sidebar hud-panel" id="sidebar-panel">
            <div class="metric-row">
                <span class="label">THROUGHPUT</span>
                <span class="value" id="val-tps">0 TPS</span>
            </div>
            <div class="metric-row">
                <span class="label">ACTIVE NODES</span>
                <span class="value" id="val-nodes">0</span>
            </div>
            <div class="metric-row">
                <span class="label">ARCHITECTURE</span>
                <span class="value" id="val-arch">PARALLEL</span>
            </div>

            <div style="margin-top:10px;">
                <span class="label">CORE MAP</span>
                <div class="grid-status" id="mini-grid"></div>
            </div>
        </div>

        <div class="hud-panel" style="align-self: center; margin-bottom: 20px;">
            <span class="label">CURRENT CONFIG: </span>
            <span id="config-text" style="color: #fff; font-size: 11px;">XC7A100T // 8x8 GRID</span>
        </div>
    </div>

    <canvas id="canvas-2d"></canvas>
    <div id="container-3d"></div>

<script>
/**
 * ------------------------------------------------------------------
 * ENTERPRISE CHIP ARCHITECT V10
 * ------------------------------------------------------------------
 * Unified engine for FPGA (Parallel) and CPU (Serial) visualization.
 */

// --- CONFIGURATION ---
const CONFIG = {
    fpga: {
        color: '#39c5bb',
        gridSize: 8, // 8x8 = 64 nodes
        label: 'XC7A100T // 8x8 DSP FABRIC',
        tpsBase: 84000
    },
    cpu: {
        color: '#f0883e',
        gridSize: 4, // 4x4 = 16 cores (High end desktop)
        label: 'i9-14900K // 16-CORE HYBRID',
        tpsBase: 4200
    }
};

// --- GLOBAL STATE ---
const state = {
    arch: 'FPGA',   // 'FPGA' | 'CPU'
    view: 'LIVE',   // 'LIVE' | '3D' | 'BLUEPRINT'
    nodes: [],      // Logic nodes
    packets: [],    // Data particles
    tps: 0,
    stress: false,
    frameCount: 0
};

// --- INITIALIZATION ---
window.onload = () => {
    initEngine();
    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);
        animate();
    }, 1000);
};

function initEngine() {
    initCanvas();
    init3D();
    buildArchitecture(); // Builds nodes based on current Arch
}

// =========================================================================
// 1. ARCHITECTURE LOGIC BUILDER
// =========================================================================

function buildArchitecture() {
    state.nodes = [];
    state.packets = [];
    
    const isFPGA = state.arch === 'FPGA';
    const cfg = isFPGA ? CONFIG.fpga : CONFIG.cpu;
    
    // UPDATE UI TEXT
    document.getElementById('config-text').innerText = cfg.label;
    document.getElementById('val-arch').innerText = isFPGA ? 'PARALLEL' : 'SERIAL/RING';
    document.getElementById('brand-header').style.color = cfg.color;

    // BUILD LOGIC NODES
    // We use a virtual coordinate system (1000x1000) mapped to screen later
    
    if (isFPGA) {
        // 8x8 GRID
        let gap = 80;
        let startX = 500 - (3.5 * gap);
        let startY = 500 - (3.5 * gap);

        for (let r=0; r<8; r++) {
            for (let c=0; c<8; c++) {
                state.nodes.push({
                    id: `DSP-${r}-${c}`,
                    x: startX + c*gap,
                    y: startY + r*gap,
                    type: 'CORE',
                    load: 0
                });
            }
        }
    } else {
        // CPU: RING BUS LAYOUT
        // 16 Cores in a ring/grid pattern
        let gap = 120;
        let startX = 500 - (1.5 * gap);
        let startY = 500 - (1.5 * gap);

        for (let r=0; r<4; r++) {
            for (let c=0; c<4; c++) {
                state.nodes.push({
                    id: `CORE-${r}-${c}`,
                    x: startX + c*gap,
                    y: startY + r*gap,
                    type: 'CORE',
                    load: 0
                });
            }
        }
        
        // Add L3 Cache Blocks (Interspersed)
        state.nodes.push({ id: 'L3-CACHE', x: 500, y: 500, type: 'CACHE', w: 500, h: 500, load: 0 });
    }

    // REBUILD MINI-MAP
    const gridEl = document.getElementById('mini-grid');
    gridEl.innerHTML = '';
    const gridSize = isFPGA ? 8 : 4;
    gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
    
    state.nodes.forEach((n, i) => {
        if(n.type === 'CORE') {
            const d = document.createElement('div');
            d.className = 'mini-node';
            d.id = `mini-${i}`;
            gridEl.appendChild(d);
        }
    });

    // REBUILD 3D SCENE
    build3DScene();
}

// =========================================================================
// 2. 2D RENDER ENGINE (LIVE & BLUEPRINT)
// =========================================================================
const canvas = document.getElementById('canvas-2d');
const ctx = canvas.getContext('2d');

function initCanvas() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
}
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

class Packet {
    constructor() {
        this.reset();
    }
    
    reset() {
        this.active = true;
        this.progress = 0;
        
        // Pick random core
        const cores = state.nodes.filter(n => n.type === 'CORE');
        const target = cores[Math.floor(Math.random() * cores.length)];
        
        // PATHING LOGIC
        // FPGA: PCIe (Left) -> Core -> Mem (Right)
        // CPU: RAM (Top) -> Cache -> Core -> Cache
        
        if (state.arch === 'FPGA') {
            this.path = [
                {x: 0, y: target.y},       // PCIe In
                {x: target.x, y: target.y}, // Core
                {x: 1000, y: target.y}     // Out
            ];
            this.speed = 0.04 + Math.random()*0.02;
        } else {
            this.path = [
                {x: 500, y: 0},            // RAM
                {x: 500, y: 500},          // L3
                {x: target.x, y: target.y}, // Core
                {x: 500, y: 500}           // Back to L3
            ];
            this.speed = 0.02 + Math.random()*0.01; // Slower CPU bus
        }
        
        this.pos = { ...this.path[0] };
        this.segment = 0;
    }
    
    update() {
        if (!this.active) return;
        
        const target = this.path[this.segment + 1];
        if (!target) {
            this.active = false;
            return;
        }
        
        const dx = target.x - this.pos.x;
        const dy = target.y - this.pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist < 5) {
            this.segment++;
            // Hit a node?
            state.nodes.forEach(n => {
                if(Math.abs(n.x - this.pos.x) < 40 && Math.abs(n.y - this.pos.y) < 40) {
                    n.load = 1.0; // Flash node
                }
            });
        } else {
            this.pos.x += (dx/dist) * this.speed * 20; // 20 is speed multiplier
            this.pos.y += (dy/dist) * this.speed * 20;
        }
    }
}

function draw2D() {
    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Setup Blueprint Styles if needed
    const isBlueprint = state.view === 'BLUEPRINT';
    const mainColor = state.arch === 'FPGA' ? CONFIG.fpga.color : CONFIG.cpu.color;
    
    // Scale Viewport
    ctx.save();
    const scale = Math.min(canvas.width/1200, canvas.height/1200);
    const offsetX = (canvas.width - 1000*scale)/2;
    const offsetY = (canvas.height - 1000*scale)/2;
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    
    // DRAW WIRES / SUBSTRATE
    ctx.strokeStyle = isBlueprint ? 'rgba(255,255,255,0.4)' : '#30363d';
    ctx.lineWidth = 2;
    
    if (state.arch === 'FPGA') {
        // Draw Grid Wires
        for(let i=0; i<=8; i++) {
            let p = 500 - (3.5*80) + (i*80) - 40;
            ctx.beginPath(); ctx.moveTo(p, 100); ctx.lineTo(p, 900); ctx.stroke(); // Vert
            ctx.beginPath(); ctx.moveTo(100, p); ctx.lineTo(900, p); ctx.stroke(); // Horz
        }
    } else {
        // Draw Ring Bus
        ctx.beginPath();
        ctx.rect(250, 250, 500, 500);
        ctx.stroke();
    }
    
    // DRAW NODES
    state.nodes.forEach(n => {
        if(n.type === 'CACHE') return; // Don't draw L3 as a box yet
        
        const size = state.arch === 'FPGA' ? 40 : 80;
        
        if (isBlueprint) {
            // Blueprint Style: Outline only, specific markings
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
            
            // X Marking
            ctx.beginPath();
            ctx.moveTo(n.x - size/2, n.y - size/2);
            ctx.lineTo(n.x + size/2, n.y + size/2);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = '10px monospace';
            ctx.fillText(n.id.split('-')[0], n.x - 20, n.y - size/2 - 5);
            
        } else {
            // Live Style: Glow, fill
            let alpha = 0.2 + (n.load * 0.8);
            ctx.fillStyle = n.load > 0.1 ? mainColor : '#21262d';
            ctx.globalAlpha = n.load > 0.1 ? 1 : 0.5;
            
            // Glow
            if(n.load > 0.1) {
                ctx.shadowColor = mainColor;
                ctx.shadowBlur = 20;
            } else {
                ctx.shadowBlur = 0;
            }
            
            ctx.fillRect(n.x - size/2, n.y - size/2, size, size);
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Border
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(n.x - size/2, n.y - size/2, size, size);
        }
        
        // Decay Load
        n.load *= 0.9;
    });
    
    // DRAW PACKETS (Only in LIVE mode)
    if (!isBlueprint) {
        state.packets.forEach(p => {
            if(!p.active) return;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.pos.x, p.pos.y, 4, 0, Math.PI*2);
            ctx.fill();
            
            // Trail
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.pos.x, p.pos.y);
            ctx.lineTo(p.pos.x - (p.path[1].x - p.path[0].x)*0.05, p.pos.y);
            ctx.stroke();
        });
    } else {
        // In Blueprint, draw static annotations
        ctx.fillStyle = '#fff';
        ctx.font = '20px monospace';
        ctx.fillText("FIG 1.1: CORE MATRIX LAYOUT", 50, 950);
        ctx.fillText("SCALE: 10nm / PROCESS", 50, 980);
    }
    
    ctx.restore();
}

// =========================================================================
// 3. 3D RENDER ENGINE (THREE.JS)
// =========================================================================
let scene, camera, renderer, controls, chipGroup;

function init3D() {
    const container = document.getElementById('container-3d');
    
    scene = new THREE.Scene();
    // No background color, allow CSS background to show through if needed, 
    // but usually we want black for 3D
    scene.background = new THREE.Color(0x050505); 
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    camera.position.set(0, 400, 400);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    
    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(100, 200, 100);
    scene.add(sun);
    
    build3DScene();
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function build3DScene() {
    if (chipGroup) scene.remove(chipGroup);
    chipGroup = new THREE.Group();
    
    const color = state.arch === 'FPGA' ? 0x39c5bb : 0xf0883e;
    const material = new THREE.MeshStandardMaterial({
        color: 0x111111,
        emissive: color,
        emissiveIntensity: 0.1,
        roughness: 0.2,
        metalness: 0.8
    });
    
    // BASE SUBSTRATE
    const baseGeo = new THREE.BoxGeometry(600, 10, 600);
    const base = new THREE.Mesh(baseGeo, new THREE.MeshStandardMaterial({color:0x050505}));
    base.position.y = -10;
    chipGroup.add(base);
    
    // BUILD NODES BASED ON 2D LOGIC
    // We map the 1000x1000 virtual 2D coords to 3D space (-300 to 300)
    state.nodes.forEach(n => {
        if(n.type === 'CACHE') return;
        
        let size = state.arch === 'FPGA' ? 30 : 70;
        let h = 20 + Math.random() * 20;
        
        const geo = new THREE.BoxGeometry(size, h, size);
        const mesh = new THREE.Mesh(geo, material.clone());
        
        // Map 0-1000 to -300 to 300
        let x = (n.x / 1000) * 600 - 300;
        let z = (n.y / 1000) * 600 - 300;
        
        mesh.position.set(x, h/2, z);
        mesh.userData = { id: n.id, originalH: h }; // Store for animation
        
        chipGroup.add(mesh);
    });
    
    // Add L3 Cache for CPU
    if (state.arch === 'CPU') {
        const cGeo = new THREE.BoxGeometry(200, 30, 200);
        const cMat = new THREE.MeshStandardMaterial({color: 0x222222, opacity: 0.8, transparent:true});
        const cMesh = new THREE.Mesh(cGeo, cMat);
        cMesh.position.y = 15;
        chipGroup.add(cMesh);
    }
    
    scene.add(chipGroup);
}

function update3D() {
    // SYNC 3D MESHES WITH LOGIC STATE
    chipGroup.children.forEach(mesh => {
        if (!mesh.userData.id) return;
        
        // Find corresponding logic node
        // (Optimization: In a real engine, we'd map this, but filter is fine for <100 nodes)
        const logicNode = state.nodes.find(n => n.id === mesh.userData.id);
        if (logicNode && logicNode.load > 0.1) {
            mesh.material.emissiveIntensity = 0.1 + (logicNode.load * 2);
            mesh.scale.y = 1 + (logicNode.load * 0.5);
        } else {
            mesh.material.emissiveIntensity = 0.1;
            mesh.scale.y = 1;
        }
    });
    
    controls.update();
    renderer.render(scene, camera);
}


// =========================================================================
// 4. MASTER LOOP & CONTROLLERS
// =========================================================================

function animate() {
    state.frameCount++;
    
    // 1. SPAWN PACKETS
    const spawnRate = state.stress ? 5 : 1;
    if (state.frameCount % (state.stress ? 2 : 10) === 0) {
        for(let i=0; i<spawnRate; i++) state.packets.push(new Packet());
    }
    
    // 2. UPDATE PACKETS
    state.packets.forEach(p => p.update());
    state.packets = state.packets.filter(p => p.active); // Cleanup
    
    // 3. UPDATE STATS UI
    // Logic: Node Count * Base Multiplier
    const activeNodes = state.nodes.filter(n => n.load > 0.1).length;
    const baseTPS = state.arch === 'FPGA' ? CONFIG.fpga.tpsBase : CONFIG.cpu.tpsBase;
    const currentTPS = Math.floor(baseTPS + (state.packets.length * 150));
    
    if (state.frameCount % 10 === 0) {
        document.getElementById('val-tps').innerText = currentTPS.toLocaleString() + " TPS";
        document.getElementById('val-nodes').innerText = activeNodes;
        
        // Update Mini-Grid
        const minis = document.getElementsByClassName('mini-node');
        for(let i=0; i<minis.length; i++) {
            if (i < state.nodes.length) {
                if (state.nodes[i].load > 0.1) {
                    minis[i].classList.add(state.arch === 'FPGA' ? 'active-fpga' : 'active-cpu');
                } else {
                    minis[i].className = 'mini-node';
                }
            }
        }
    }

    // 4. RENDER
    if (state.view === '3D') {
        update3D();
    } else {
        draw2D();
    }
    
    requestAnimationFrame(animate);
}

// UI ACTIONS
function switchArch(arch) {
    if(state.arch === arch) return;
    state.arch = arch;
    
    // Buttons
    document.getElementById('btn-arch-fpga').classList.toggle('active-fpga', arch === 'FPGA');
    document.getElementById('btn-arch-cpu').classList.toggle('active-cpu', arch === 'CPU');
    
    buildArchitecture();
}

function switchView(view) {
    state.view = view;
    document.body.className = `view-${view.toLowerCase()} mode-${view === 'BLUEPRINT' ? 'blueprint' : 'dark'}`;
    
    // Buttons
    ['live', '3d', 'blue'].forEach(v => {
        document.getElementById(`btn-view-${v}`).classList.remove('active-view');
    });
    let key = view === 'BLUEPRINT' ? 'blue' : view.toLowerCase();
    document.getElementById(`btn-view-${key}`).classList.add('active-view');
}

function triggerLoad() {
    state.stress = true;
    setTimeout(() => state.stress = false, 2000); // 2s burst
}

</script>
</body>
</html>
